<!--
https://ae01.alicdn.com/kf/H6afaf3902644461a866e1e09bf6004480.png
框架设计
缓存学习
适当的利用缓存，可以有效的提高整体性能
适当的利用缓存，可以有效的提高整体性能
-->

## 缓存学习

> 适当的利用缓存，可以有效的提高整体性能

#### 为什么使用缓存 
缓存主要用途即高性能、高并发。  
比如A用户发起请求，服务器从数据库查询结果data1，花费了800ms，此时用户B也同样发起请求，查询数据data1，
则需要再次花费800ms，则在一天内，data1是不会变化的，故对于此种数据，我们可以利用缓存，
其余用户查询数据data1时，在缓存中查询到了记录，则立即返回。缓存数据很快，可能仅需10ms即可完成。

#### 常用有redis、memcached
redis是单线程工作模型，redis采用IO多路复用+事件分发器+事件处理器搭建异步处理模型，
而且redis的数据类型比memcached多，也原生支持集群模式。

能够实现高并发主要还是因为是基于内存的操作。

* redis功能，应用场景：string、hash、list、set、sort set。  
string就是最普通的set和get，存取key/value  
hash类数据结构，主要可以用来存放一些对象。后续操作时候可以仅仅只修改该对象中的某个属性。
* 缓存数据是会过期的，要么自己设置过期时间，要么redis自己干掉了。过期策略：定期删除和惰性删除  
    * 定期删除：每隔100ms就随机抽取一些设置了过期时间的key，检查是否过期并操作。
    * 惰性删除：获取key的时候，会先检查是否设置了过期时间，然后是否过期，过期则删除不会返回数据
    * 内存淘汰：当redis内存满载时，会有删除策略  
    1、noevuction：满载时，写入报错  
    2、allkeys-lru：满载时，删除最近使用最少的key  
    3、allkeys-random：随机删除  
    4、volatile-lru：再设置了过期时间的key中，删除最近使用次数最少的  
    5、volatile-random：再设置了过期时间的key中随机删除  
    6、volatile-ttl：再设置了过期时间的key中，有更早过期的key优先删除
    
    
#### 如何缓存与数据库的双写一致性
1、极端情况下，可以采用读写串行化，保证数据高度一致。到那时总体效率就会下降。

2、CAP（Cache Aside Pattern）  
即缓存+数据库的读写模式。  
* 读的时候，先从缓存中读取数据，数据不存在则从数据库中读取，并写到缓存中，然后返回响应。
* 更新的时候，先更新数据库，再删除缓存。  
    * 为什么时删除缓存。需要根据场景而定。  
    某些业务场景中，缓存存储的数据不单单时从数据库的原始数据，而可能时通过某些规则计算出来的。
    如果我们频繁的更新数据库，就意味着需要频繁的更新缓存，但是这些缓存可能被不会被立即用到。
    此处我们就采取惰性加载的思路，只有当数据被使用的时候，才会取数据库中获取并缓存。

#### 缓存存在的问题
1、缓存雪崩  
当缓存服务器故障，直接导致大量的请求直接访问数据库，导致数据库崩溃。  

从redis的角度来看，需要对redis做集群，防止缓存集体奔溃，可能机房出问题，导致机体奔溃，我们也可以分机房配置。
然后可以对redis做持久化处理，一旦回复设备后可以立即从磁盘中读取缓存。

从数据的角度来看，数据库无法承受大量请求，底线就是数据库需要存活且提供服务。
我们可以使用限流组件，一旦流量超过阈值，则请求走降级处理，也就是返回配置好的默认值。

2、缓存穿透  
当发起大量，缓存及数据库中不存在对应数据的请求时，该请求将无视缓存，总是直接访问服务器，导致数据库崩溃。  

可以设置返回结果为空，并存储再缓存中。针对恶意的查询，可以封禁处理。


3、缓存击穿  
当热点数据，突然过期，导致大量请求直接访问数据库，导致数据库崩溃。  

针对这种情况，一般都是设置定时更新任务，再过期之前更新热点数据的缓存。

#### redis并发竞争  
1、并发竞争  
多客户端同时操作一个key值，结果不是按正常的顺序操作的，导致数据错了  

redis的数据是从数据库中读取出来的，写入mysql的时候保留一个时间戳，然后
我们可以从数据库中取值的时候，取出时间戳，每次更新数据时，对比时间戳，保证数据时最新的。  
redis有自己的分布式锁机制，我们采用分布式锁，保证每次只有一次服务器能够修改数据。

2、redis的CAS方案

#### redis内存机制
![redis](https://ae01.alicdn.com/kf/Hfdea933b4bd142e9a3a0fc2d830a7b35k.png)
1、数据结构：  
> string-key:value  
> hash  
> list  
> set  
> sort set

2、过期机制：  
> 定期删除   
> 惰性删除  

3、内存淘汰机制：  
> noeviction  
> allkeys-lru  
> allkeys-random  
> volatile-lru  
> volatile-random  
> volatile-ttl
