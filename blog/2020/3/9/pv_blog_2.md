<!--
https://ae01.alicdn.com/kf/Haf4d3b0529ba47669bf69c7bfc71a5f1Y.png
框架设计
缓存学习
适当的利用缓存，可以有效的提高整体性能
适当的利用缓存，可以有效的提高整体性能
-->

## 缓存学习

> 适当的利用缓存，可以有效的提高整体性能

#### 为什么使用缓存
比如A用户发起请求，服务器从数据库查询结果data1，花费了800ms，此时用户B也同样发起请求，查询数据data1，
则需要再次花费800ms，则在一天内，data1是不会变化的，故对于此种数据，我们可以利用缓存，
其余用户查询数据data1时，在缓存中查询到了记录，则立即返回。缓存数据很快，可能仅需10ms即可完成。

#### 常用有redis、memcached
redis是单线程工作模型，而且redis的数据类型比memcached多，redis采用IO多路复用+事件分发器来实现，能够实现高并发主要还是因为是
基于内存的操作。

* redis功能，应用场景：string、hash、list、set、sort set。  
string就是最普通的set和get，存取key/value  
hash类数据结构，主要可以用来存放一些对象。后续操作时候可以仅仅只修改该对象中的某个属性。
* 缓存数据是会过期的，要么自己设置过期时间，要么redis自己干掉了。过期策略：定期删除和惰性删除  
    * 定期删除：每隔100ms就随机抽取一些设置了过期时间的key，检查是否过期并操作。
    * 惰性删除：获取key的时候，会先检查是否设置了过期时间，然后是否过期，过期则删除不会返回数据
    * 内存淘汰：当redis内存满载时，会有删除策略  
    1、noevuction：满载时，写入报错  
    2、allkeys-lru：满载时，删除最近使用最少的key  
    3、allkeys-random：随机删除  
    4、volatile-lru：再设置了过期时间的key中，删除最近使用次数最少的  
    5、volatile-random：再设置了过期时间的key中随机删除  
    6、volatile-ttl：再设置了过期时间的key中，有更早过期的key优先删除
    

<!-- 主要是要问redis单机承载性能，多高的并发量。单机扛不住如何扩容。redis会不会挂，如何保证高可用 -->
<!-- 
 
 redis高并发的瓶颈：单机导致
 如果redis要支撑10万的并发，基本就是读写分离。缓存一般是用来支撑读高并发，写的请求是比较少的。
 
 
 redis主从复制，读写分离
 主从架构 -> 读写分离架构 -> 水平扩展的读高并发架构
master数据同步到slave，是异步的。即replication功能。
master再本地生成一个RDB文件，是全量的文件，发送给slave。然后会发送变化数据给slave

 redis哨兵原理
 
 
 mysql
 分库分表
 1、为什么要分库分表
 为了支撑高并发、数据量大两个问题。会扯到高并发。
 业务场景：
 单机mysql扛不住高并发
 mysql单机磁盘有限
 mysql单表数据量太大了，sql越跑越慢
 
 数据库中间件，将数据分类，分到不同的库中
 垂直拆分，把使用频率较高的字段拆离开来，不常用的字段也拆离开来
 水平拆分，类似分库，把一个完整的表，水平来一刀。拆成两个表，表结构是一样的
 
 中间件，就包括一些hash取模等方法，帮助我们定位库表，也就是分发数据
 如何定义某条数据在哪个库和表。可以使用取模的基本算法。比如3个库，每个库有4个表，然后每一个id，其实都可以定位到一个具体的库表
 单个库最高承载2000 s/QPS

mongodb其实也可以分库分表，不过不能这么叫了。原理是很赞的。

过程：
0.1、选择数据库中间件
0.2、涉及你的分库分表的方案，分成多少个库，每个库多少个表
0.3、测试能够正常分库分表读写
0.4、完成单库单表的迁移

一台数据库服务器，能承载2000/s的写并发。四台则支持8000/s的写并发
第一种库容，直接迁移库，4台服务器，每个服务器8个库，每个库32张表
扩容就是，将库迁移，也就是8台服务器，每个服务器4个库，每个库32张表，只不过是将库迁移到了新的服务器，增大写入。
由此类推，最多可以扩容到32个服务器，每个服务器1个库，每个库32张表
当还需要扩容的时候，还可以分表，最多1024个服务器，每个服务器1个库，一张表。
这种方案的好处就是，可以不用改变表的数量，只需要改变数据库服务器的数量即可增加性能。
即不需要做数据迁移，没有取出分发的过程
故设计的时候，1个数据库服务器，32个库，每个库32张表。倍数扩容。

还有一个要点，就是数据库的主键id需要全局唯一，故我们就需要一个生成主键的库，且是仅有一个。
一般有：主键自增、uuid、时间戳、snowflake
 
 snowflake: 64位，首位为0 + 时间戳41位 + 机房id5位 + 机器id5位 + 序号12位
 序号表示同一机房机器，再同一时间发起请求
 
 mysql如何实现读写分离。主从复制原理是什么，如何解决主从同步的延时问题
 
 什么情况下，缓存里读不到数据
 1、缓存刚加上去，并没有把数据库中的历史数据导入
 2、缓存的内存塞满了，自动LRU了，删除了一些数据
 
 mysql有binlog日志，就是每个增删改类的操作，会改变数据的操作，除了更新数据意外，
 对这个增删改操作还会写入一个日志文件，记录这个操作
 
 从库读取binlog日志，写relay日志，应用日志变更到本地数据，是串行化的，导致从库数据会比主库数据慢
 这就是主从同步延时的原理
 
 2、用过那些分库分表的中间件
 
 3、具体如何分库分表的
 
 读写分离
 -->





