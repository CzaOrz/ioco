<!--
http://attach.bbs.miui.com/forum/201305/24/123936nq3qmi7a3qjx2o3i.jpg
数据库事务
数据库事务的基本概念、隔离级别、及可能造成的问题。包括四种隔离级别ReadUncommit、ReadCommit、RepeatableRead、Serializable
从需求上讲即某些业务上的要求，需要某一系列操作全部执行，如果其中有一个操作失败，则全部失败。  从概念上讲。即某些SQL语句，要么全部执行成功，要么全部执行。* A（Atomic）原子性：即所有的操作如一个原子，不可分割，要么全部执行，要么全不执行
-->

## 数据库事务

> 数据库事务的基本概念、隔离级别、及可能造成的问题。包括四种隔离级别ReadUncommit/ReadCommit/RepeatableRead/Serializable

#### 概念
**数据库事务**  
从需求上讲即某些业务上的要求，需要某一系列操作全部执行，如果其中有一个操作失败，则全部失败。  
从概念上讲。即某些SQL语句，要么全部执行成功，要么全部执行

* A（Atomic）原子性：即所有的操作如一个原子，不可分割，要么全部执行，要么全不执行
* C（Consistent）一致性：即所有命令执行后，数据库的状态是一致的。如A账号减一，则对应的B账号应该加一
* I（Isolation）隔离性：即各事务之间应该相互隔离，不影响
* D（Duration）持久性：即事务完成后，对数据的修改，应该被持久化存储

#### 隔离级别
对于并发执行的事务，可能存在问题如：脏读，不可重复读、幻读等
* 脏读
* 不可重复读：在同一事物中不可重读读取某一条数据。应该可能读到其他事务已提交数据
* 幻读：首次读取数据不存在。但更新时可以成功，再次读取就出现了这条数据。

**默认隔离级别为：Repeatable Read**  
* Read Uncommitted：隔离级别最低。
    * 能够读取到其他事务未提交的数据。则可能在同一事务中的两次读取，得到不同的数据。
    因为其他事务没有commit，得到了此时的数据。  
    而之后该事务回滚，则上次事务读取又得到一个不同值。此为脏读。
* Read Committed
    * 能够读到其他事务已提交的数据。  
    即在同一事务中，同时读取两次，还是可能得到不同值，因为可以读到其他事务已提交的记录
* Repeatable Read
    * 无法获取其他事务已提交数据，但是可以更新，更新后可已读取
* Serializable
    * 是最严格的隔离级别。所有事务需要依次执行。
    
