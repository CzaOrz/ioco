<!--
http://hbimg.b0.upaiyun.com/3d7f6e9b404a35a87a9e0a147c8321033f0206f53188a-PGCDV7_fw658
Python内存管理
其中Python内存管理由私有堆空间管理，所有的Python对象和数据结构都存储在私有堆中，只有解析器才有权限访问。  
首先通过引用计数，来保持追踪内存中的对象，以便进行创建和回收； 其次通过 “标记-清除” 解决容器对象可能产生的循环引用问题；然后通过 “分代回收” 以空间换时间的方法提高垃圾回收效率。
-->

## Python内存管理

> 其中Python内存管理由私有堆空间管理，所有的Python对象和数据结构都存储在私有堆中，只有解析器才有权限访问。  
> Python内存管理主要分为：引用计数、垃圾回收、内存池机制  

**总体来说：**
* 首先通过引用计数，来保持追踪内存中的对象，以便进行创建和回收；
* 其次通过 “标记-清除” 解决容器对象可能产生的循环引用问题；
* 然后通过 “分代回收” 以空间换时间的方法提高垃圾回收效率。

#### 引用计数
常规的赋值，就包含对象的创建、引用等过程，如下：
```python
x = 3
y = x
```
首先在内存中创建整数对象3，然后将创建变量x，将x指向整数的地址，实现对象的创建与引用

#### 垃圾回收
垃圾回收也主要是通过引用计数实现的。
```
typedef struct_object {
    int ob_refcnt;  // 引用计数器
    struct_typeobject *ob_type;
} PyObject;  // 核心结构体
```
每一个对象中都维护由一个引用计数器，当该对象引用计数为0的时候，就会释放其内存。

**一般引用计数增加：**
* 对象被创建
* 对象被引用
* 对象被作为参数，传入到一个函数中
* 对象作为一个元素，存储在容器中

**一般引用计数减少：**
* 对象别名被显示销毁 del
* 对象别名被赋予新的对象
* 一个对象离开他的作用域

而且引用计数有一个致命的缺点，就是循环引用，无法清除相互之间的引用计数。

**故引入标记-清除算法**  
遍历所有的对象。如果对象是可达的，也就是还有对象引用它，就标记该对象为可达。  
在进行垃圾回收的时候分为两步：
* A：标记阶段 》》遍历所有的对象。如果对象是可达的，也就是还有对象引用它，就标记该对象为可达。
* B：清除阶段 》》再次遍历对象。弱某对象没有标记为可达，将其回收。

**分代回收**  
分代回收是基于这样的一个统计事实。  
对于程序，存在一定比例的内存块的生存周期比较短；  
而剩下的内存块，生存周期会比较长，甚至会从程序开始一直持续到程序结束；  
生存期较短对象的比例通常在 80%～90% 之间，这种思想简单点说就是：  
【对象存在时间越长，越可能不是垃圾，应该越少去收集】  
这样在执行标记-清除算法时可以有效减小遍历的对象数，从而提高垃圾回收的速度。

记录分配次数与取消分配对象的次数，达到一定阈值就会触发0代的垃圾回收。

#### 内存池机制
Python提供了对内存的垃圾收集机制，但是它将不用的内存放到内存池而不是返回给操作系统。

Python中所有小于256个字节的对象都使用pymalloc实现的分配器，而大的对象则使用系统的 malloc。
另外Python对象，如整数，浮点数和List，都有其独立的私有内存池，对象间不共享他们的内存池。
也就是说如果你分配又释放了大量的整数，用于缓存这些整数的内存就不能再分配给浮点数。