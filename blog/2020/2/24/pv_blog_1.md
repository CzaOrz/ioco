<!--
https://ae01.alicdn.com/kf/H127983aa4ee845f5bb99ef81d1cbb2e2Z.png
爬虫|框架设计
分布式爬虫调度（一）
基于Flask、Flask-APScheduler、Scrapy、RabbitMQ、Redis、Mongodb等搭建分布式爬虫调度框架  
整体框架由client端、master端、中间件、数据库、salve端构成。此框架前后端分离，前端暂时部署在github page上，后端只提供数据和调度服务。 其中master端由两个服务器组成，分别提供调度服务和数据分析服务 
-->

## 分布式爬虫调度（一）

> 基于Flask、Flask-APScheduler、Scrapy、RabbitMQ、Redis、Mongodb等搭建分布式爬虫调度框架  

#### 整体框架结构
![分布式爬虫框架](https://ae01.alicdn.com/kf/H757295bed18a4a58bb5cc51672034695S.png)

由图中我们可以看出，整体框架由client端、master端、中间件、数据库、salve端构成。  
此框架前后端分离，前端暂时部署在github page上，后端只提供数据和调度服务。  

其中master端由两个服务器组成，分别提供调度服务和数据分析服务

### scheduler
**调度模块**  
后端调度模块由APScheduler模块提供，生成task任务
> 该模块中的task调度任务，由threading.wait()提供核心的时延服务  
> 将用户创建任务进行排序后，剔除并取出最小任务进行wait()操作  
> 直至超时触发任务执行，然后计算下次执行时间并重新入队，调整队列顺序重新执行

**节点模块**  
scheduler端以RabbitMQ作为broker，发布调度生成的task任务，而消费节点则订阅并执行调度任务。  
消费节点配置有相应的调度规则，是命令的执行者，开发人员可在此处配置爬虫及任务规则

**爬虫模块**  
而爬虫spider独立于整个框架外，是真正的命令执行单元，且配置有单独的git进行维护，支持自更新。  
爬虫是基于Scrapy开发，需要在各节点的终端执行scrapy执行运行，效率较高。
> Scrapy是基于twisted搭建的异步爬虫框架。由engine、schedule、downloader、spider、pipeline组成。

**RPC机制**  
在发布订阅的基础上，引入RPC通道，提供Server端管理各节点的能力。  
包括杀掉节点任务，清除节点异常进程，远程执行节点命令等功能。

**回查机制**  
针对节点异常断电重启，被抢占进程导致杀掉等特俗情况，由于缓存数据均存在redis中  
故存在数据无法清除的情况，在客户端也无法判断该任务是否未正常任务。故在server引入定时回查机制，
定时的检查节点是否正常，并检查各节点任务是否正常存活。若不存在该进程，则自动清除异常任务。

### analysis

|功能|模型|算法|
|---|---|---|
|新闻分类|NaiveBayes|朴素贝叶斯算法|
|房价预测|LogisticRegression|梯度下降算法|

朴素贝叶斯算法：  
基于词频的统计模型。假设各特征之间无关联，在给定目标向量的前提下，计算该向量
属于各个类别标签的概率，并取其中最大的为最终分类。  
```p(c|x) = p(c)*p(c|x) / p(x)```  
p(c)表示各标签概率  
p(x)表示目标向量  
p(c|x)表示在给定目标向量的前提下，属于标签c类别的概率  
p(x|c)表示在给定标签c类别，然后x发生的概率

梯度下降算法：
对于线性或者多元非线性模型，我们计算模型的代价函数，也可以理解为该模型在某点的```斜率```  
得到代价函数后，我们即可往该方向步进，接近最值。

原理：Cost'相当于斜率，修正W用此方法，往斜率方向步进，得到修正值  
```
Cost = -{∑[-y*log(h(x)) + (1-y)*log(1-h(x))]} / m
Cost' = ∑[x(h(x)-y)] / m
```

<!--
总结分布式爬虫调度系统面试中可能会被问的问题
1、爬虫调度系统时如何架构的
2、为什么要采用分布式系统
3、系统中缓存时如何使用的
4、如何保证分布式系统的高可用性

-->

