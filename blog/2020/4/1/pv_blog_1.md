<!--
https://ae01.alicdn.com/kf/Haf4d3b0529ba47669bf69c7bfc71a5f1Y.png
redis
redis学习（一）
redis的单线程模型，以及6.0之后引入了多线程机制
redis的单线程模型，以及6.0之后引入了多线程机制
-->

## redis学习（一）

> redis的单线程模型，以及6.0之后引入了多线程机制

#### IO多路复用
单线程同时检测若干个文件描述符是否可以执行IO操作的能力
> 逻辑控制流在时间上的重叠叫做 **并发**
>
> 而 CPU 单核在同一时刻只能做一件事情，一种解决办法是对 CPU 进行**时分复用** (多个事件流将 CPU 切割成多个时间片，不同事件流的时间片交替进行)。  
> 在计算机系统中，我们用线程或者进程来表示一条执行流，通过不同的线程或进程在操作系统内部的调度，来做到对 CPU 处理的时分复用。  
> 这样多个事件流就可以并发进行，不需要一个等待另一个太久，在用户看起来他们似乎就是并行在做一样。

但凡事都是有成本的。线程/进程也一样，有这么几个方面：  
1、线程/进程创建成本  
2、CPU 切换不同线程/进程成本 Context Switch  
3、多线程的资源竞争

在单线程/单进程中处理多个事件流，即IO复用。  
IO多路复用 解决问题的本质是**用更少的资源完成更多的事情**

#### IO模型
> 阻塞 IO  
> 非阻塞 IO  
> IO 多路复用  
> 信号驱动 IO  
> 异步 IO

* 阻塞 IO
    * 阻塞IO意味在发起一次IO操作后，一直等待直到成功或者失败才返回。在这期间程序不能做其他的事情，阻塞IO只能针对单个文件描述符进行操作。
* 非阻塞 IO
    * 非阻塞IO即在发起IO操作后不阻塞，但当起状态未改变的时候，进行操作则会处罚异常错误
* IO多路复用
    * 在Linux中包括了三种select、poll、epoll等。针对某个文件描述符，进行相应的事件注册，然后触发回调函数。
* 信号驱动 IO
* 异步 IO

#### redis单线程 
redis之所以被称之为单线程，是因为他的请求获取、解析、执行、内容返回等，都是在同一个线程中操作。所有的操作都是串行执行。

单线程机制使得内部复杂度大大降低，但是单线程也导致了redis的QPS瓶颈。  
多线程机制有两个直观优点：  
1、可以充分利用多核CPU的资源  
2、多线程任务可以分摊redis同步IO读写负荷

redis使用的是同步非阻塞IO，也就是通过IO多路复用机制，搭建一个事件驱动机制模型。非阻塞IO在调用时不会因为等待IO事件而则色，
而是在事件发生时通过一部的方式通知用户进行处理，极大的提高了处理效率。

redis基于IO多路复用机制，搭建事件回调模型，对于阻塞IO操作进行异步处理，所以整体来说这就是一个单线程，高性能的核心。

但是IO数据的读写，依然是阻塞的。这也就是redis目前主要的性能瓶颈之一。在数据吞吐量较大的时候，比较明显。  
此处需要考虑到操作系统的一个数据转移过程，当socket中有数据的时候，通过IO多路复用，系统将数据从内核态拷贝到用户态，然后进行后续的操作。
这个拷贝过程是阻塞的，也就是说当拷贝的数据量越大，那么延迟也就越高，整体操作就将进行阻塞。

redis6.0引入的多线程机制就是针对此瓶颈进行的优化，核心思路即，将主线程的IO读写任务拆分出来，给一组独立的线程执行，使得多个socket的读写可以并行化。
但是命令的执行依然是在主线程串行化执行的。

流程简述如下：  
* 主线程获取 socket 放入等待列表
* 将 socket 分配给各个 IO 线程
* 主线程阻塞等待 IO 线程读取 socket 完毕
* 主线程执行命令 - 单线程
* 主线程阻塞等待 IO 线程将数据回写 socket 完毕
* 解除绑定，清空等待队列

有如下特点：
* IO 线程要么同时在读 socket，要么同时在写，不会同时读或写
* IO 线程只负责读写 socket 解析命令，不负责命令处理
* IO 线程数可自行配置（目前代码限制上限为 512，默认为 1(关闭此功能)）
